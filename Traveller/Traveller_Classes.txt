4/20/23
Reviewing classes, esp. w.r.t. JSON representation.
Focusing on System for now as that's where most of the effort
is going (and outside this cluster classes are mostly app scaffolding).

                                          VERIFY JSON
=====================================     =================================
System
-------------------------------------
Polygon hex                                n/a - regenerate on load
Coordinate coord                           OK (JSONObject)
Boolean occupied                           OK (primitive)
UWP uwp                                    OK (JSONObject)
Boolean navalBase                          OK (primitive)
Boolean scoutBase                          OK (primitive)
Boolean gasGiant                           OK (primitive)
TradeClass trade                           n/a - regenerate on load
String name                                OK (primitive)
ArrayList<Route> routes                    n/a - regenerate from separate list
-------------------------------------
System(Coordinate)
System(JSONObject)

TradeClass generateTradeClass(UWP)
UWP generateUWP()
UWP generateUWP(JSONObject)
Boolean generateScoutBase()
Boolean generateNavalBase()

void addRoute(Route)
int distanceToSystem(System)
String listRoutes()

String toString()
JSONObject asJSON()
=====================================

=====================================
System_CT81 extends System
-------------------------------------
String travelZone                          OK (primitive)
-------------------------------------
System_CT81(Coordinate)
System_CT81(JSONObject)

TradeClass generateTradeClass(UWP)
UWP generateUWP()
UWP generateUWP(JSONObject)
String generateTravelZone()

String toString()
JSONObject asJSON()
=====================================

=====================================
System_ScoutsEx extends System_CT81
-------------------------------------
Star primary                               OK (JSONObject)
-------------------------------------
System_ScoutsEx(Coordinate)
System_ScoutsEx(JSONObject)

String toString()
JSONObject asJSON()
=====================================


=====================================
abstract Orbit
-------------------------------------
Orbit barycenter                           ??
String name                                ??
int orbitNumber                            OK (primitive on subclasses)
String orbitalZone                         ??

Habitable[] moons                          ??

Dice roll                                  n/a - regenerate on load
-------------------------------------
Orbit(Orbit, int, String)

void createSatellites(int)
int generateSatelliteSize()

Boolean isOrbitingClassM()
Boolean isInnerZone()
Boolean isHabitableZone()
Boolean isOuterZone()
Boolean isAtLeastTwoBeyondHabitable()

Boolean isStar()
Boolean isEmpty()
Boolean isForbidden()
Boolean isNull()
Boolean isGasGiant()
Boolean isPlanet()
Boolean isPlanetoid()
Boolean isMoon()
Boolean isRing()

String toString()
=====================================


// we are using 'star class' to pack three
// values into a string - should the fields change to match?
// just supply methods for when a client need to know type etc.

// also rename the 'get' methods - they look like accessors
// but are actually creational

// String unpacking alone may not be enough data -
// the orbitNumber needs to be added as well (special cases
// for primary and close companion - null & -1? - don't 
// like these 'magic numbers' though)

// we also have overlap/conflict between orbits & companion
// lists when loaded from JSON - fix!   ASSESS, companions is now a query

// companion might be better as a query against orbits[]  - DONE!
// and by extension could do the same for other categories of satellite
=====================================
Star extends Orbit                         
-------------------------------------
System parent                              n/a - regenerate on load
Boolean primary                            n/a - regenerate on load
int typeRoll                               n/a - only needed at creation time
int sizeRoll                               n/a - only needed at creation time

char type                                  OK (String unpacking)
int decimal                                OK (String unpacking)
int size                                   OK (String unpacking)

//ArrayList<Star> companions           OK (JSONArray - JSONObjects) DEPRECATED
Star closeCompanion                        OK (JSONObject)
Orbit[] orbits                             OK (JSONArray - Strings)
String[] orbitalZones                      OK - regenerate on load
int gasGiantCount                          TBD (probably regen on load)
-------------------------------------
Star(Boolean, System)
Star(Boolean, System, String)              DEPRECATE
Star(Boolean, System, JSONObject)

Boolean isStar()

char generateType()
int generateSize()
void classFromString(String)
String[] retrieveOrbitalZones()

void createSatellites()
int generateCompanionCount()
int generateCompanionOrbits()
int calculateMaxOrbits()
Orbit[] createOrbits(int, int)
void placeCompanions(int, int)
void placeNullOrbits()
void placeEmptyOrbits(int, int)
void placeForbiddenOrbits()
void placeCapturedPlanets()                STUB, needs some thought
void placeGasGiants()
void placePlanetoidBelts()
void placePlanets()
int getRandomNullOrbit()
IntList availableOrbitsForGiants()
IntList availableOrbitsForPlanetoids()

ArrayList<Star> getCompanions()

Boolean orbitIsTooHot(int)
Boolean orbitIsNull(int)
Boolean orbitIsNullOrEmpty(int)
Boolean orbitInsideStar(int)
Boolean orbitIsFar(int)
Boolean orbitMaskedByCompanion(int)

String sizeToString()
int sizeFromString()

String toString()
JSONObject asJSON()
=====================================

=====================================
Empty extends Orbit
-------------------------------------
-------------------------------------
Empty(Star, int, String)

Boolean isEmpty()
=====================================

// long term this one and Empty may merge together
// but for now it helps to visualize the algorithm steps
// (what if they had a 'memo' field instead?)
=====================================
Forbidden extends Orbit
-------------------------------------
-------------------------------------
Forbidden(Star, int, String)

Boolean isForbidden()
=====================================

// null object added to help build out the
// algorithm - should only exist while the
// system is being populated
// unclear if this will stay in the final design
=====================================
Null extends Orbit
-------------------------------------
-------------------------------------
Null(Star, int, String)

Boolean isNull()
=====================================

=====================================
GasGiant extends Orbit
-------------------------------------
String size                                TBD
-------------------------------------
GasGiant(Star, int, String)

Boolean isGasGiant()

int generateSatelliteCount()
int generateSatelliteSize()

String toString()                 overloaded to show moon list structure
=====================================

=====================================
interface Habitable
-------------------------------------
-------------------------------------
abstract UWP_ScoutsEx generateUWP()
=====================================

=====================================
Planet extends Orbit implements Habitable
-------------------------------------
UWP_ScoutsEx uwp                          ?? 
-------------------------------------
Planet(Orbit, int, String)

int generateSatelliteCount()
int generateSatelliteSize()
UWP_ScoutsEx generateUWP()

Boolean isPlanet()

String toString()                 overloaded to show moon list structure
=====================================

=====================================
Planetoid extends Orbit implements Habitable
-------------------------------------
UWP_ScoutsEx uwp                          ?? 
-------------------------------------
Planetoid(Orbit, int, String)

UWP_ScoutsEx generateUWP()

Boolean isPlanetoid()
=====================================

// still assessing whether following are
// useful - could also implement this
// via queries alone (class + barycenter.class)

=====================================
Moon extends Planet
-------------------------------------
-------------------------------------
Moon(Orbit, String)

Boolean isMoon()
=====================================

=====================================
Ring extends Planetoid
-------------------------------------
-------------------------------------
Ring(Orbit, String)

Boolean isRing()
=====================================


May need to rejigger the Orbit hierarchy. We have three kinds of things
in this tree that need to be mixed together:

- objects that orbit other objects (Orbit hierarchy)
- objects that can have other objects orbiting them (Orbit superclass)
- objects that have a UWP (Habitable superclass)

The first two are the Composite pattern. The contrast between Gas Giant & Planet
on the one hand, and Planet/Moon vs. Planetoid/Ring are the crux of
the matter.

There's shared implementation in both Orbit & Habitable that's worth keeping,
so can't just make one an interface without moving some things around. This 
could be motivation to pull all the query methods up from Habitable. Then
it could be an interface that exposes the UWP mechanics.

                      |   TRUE             |   FALSE          |
----------------------|--------------------|------------------|
Can have children     |   (Orbit)          |   (Habitable)    |
                      |   Star             |   Empty          |
                      |   Gas Giant        |   Forbidden      |
                      |   Planet           |   Null           |
                      |                    |   Planetoid      |
                      |                    |   Moon           |
                      |                    |   Ring           |
----------------------|--------------------|------------------|
Has a UWP             |   (Habitable)      |   (Orbit)        |
                      |   Planet           |   Star           |
                      |   Moon             |   Gas Giant      |
                      |   Planetoid        |   Empty          |
                      |   Ring             |   Forbidden      |
                      |                    |   Null           |
----------------------|--------------------|------------------|

(Orbit)
  Empty
  Forbidden
  Null
  Star
  GasGiant
  (Habitable)    ---- XXX now an interface
    Planet
    Planetoid
    Moon
    Ring

OK, trying this out. Habitable is now an interface used by
Planet & Planetoid.

5/6/23

Reviewed Composite and have some thoughts about cleaning this up. Motivation
is the "find the mainworld" code, which would be much simpler if we could 
walk through the tree uniformly.

In addition to the muddled hierarchy described above, the collections are
implemented differently:

- Stars have an array of Orbits
- Orbits have a TreeMap of Habitables (this isn't used by Stars,
    only by GasGiants + Planets)

So - I think we want a TreeMap of Orbits used by all composite classes.
(Added benefit: the TreeMap would allow Float indices, so we could
handle Captured Planets too.)

In the pattern terminology, the classes are:

Component - (Orbit)
Composite - Star, GasGiant, Planet
Leaf      - Empty, Forbidden, Null, Planetoid, Moon, Ring

(Habitable) as already noted is orthogonal to this structure. It means "has
a UWP" and is an interface implemented by Planet/Moon/Planetoid/Ring.


=========================================
5/26/23

Above reworking is essentially complete (and Scouts is nearly feature complete).
Lots of technical debt and no doubt bugs to handle from here. Exploring the space 
below.


-------------------------------------------
Scenario: NEW, rules == "Scouts (Extended)"
-------------------------------------------

REVIEW for overrides/polymorphic calls

new Subsector()
  [for each coordinate]: 
    ruleset.newSystem()
      System_ScoutsEx.ctor()
        System_CT81.ctor()
          System.ctor()
            [UI/utility stuff]
            [set / if occupied]:
              System_CT81.generateUWP()        // overridden, timing issue, is 'rerun'
                UWP_CT81.ctor()
              System.generateNavalBase()       // timing issue, is rerun
              System.generateScoutBase()       // timing issue, is rerun
              [set / if GasGiant]              // timing issue, is rerun
              System_CT81.generateTradeClass() // overridden, timing issue, is rerun
                TradeClass_CT81.ctor()
              [set name]
              [initialize routes list]
          System_CT81.generateTravelZone()     // -- timing issue, need to rerun
        Star.ctor()
          Orbit.ctor()
          Star.generateType()
          Star.generateSize()
          Star.retrieveOrbitalZones()
        Star.createSatellites()
          Star.generateCompanionCount()
          [for each companion]:
            Star.ctor()
            Star.generateCompanionOrbits()
          Star.calculateMaxOrbits()
          Star.placeNullOrbits()
            Null.ctor()
              Orbit.ctor()
          Star.fillEmptyOrbits()
            Empty.ctor()
              Orbit.ctor()
          Star.placeEmptyOrbits()
            Star.getRandomUnassignedOrbit()
            Empty.ctor()
              Orbit.ctor()
          Star.placeForbiddenOrbits()
            Forbidden.ctor()
              Orbit.ctor()
          Star.placeCapturedPlanets()          // still just a stub
          Star.placeGasGiants()
            Star.availableOrbitsForGiants()
            GasGiant.ctor()
              Orbit.ctor()
              GasGiant.generateSatelliteCount()
              Orbit.createSatellites()
                xxx

          Star.placePlanetoidBelts()
            Star.availableOrbitsForPlanetoids()
            Planetoid.ctor()
              Orbit.ctor()
              Planetoid.generateUWP()
                UWP_ScoutsEx.ctor()
                  UWP_ScoutsEx.generateSize()        // override
                  UWP_ScoutsEx.generateAtmo()        // override
                  UWP_ScoutsEx.generateHydro()       // override
                  UWP_ScoutsEx.generatePop()         // override
          Star.placePlanets()
            Planet.ctor()
              Orbit.ctor()
              Planet.generateUWP()
                UWP_ScoutsEx.ctor()
                  UWP_ScoutsEx.generateSize()        // override
                  UWP_ScoutsEx.generateAtmo()        // override
                  UWP_ScoutsEx.generateHydro()       // override
                  UWP_ScoutsEx.generatePop()         // override
              Planet.generateSatelliteCount()
              Orbit.createSatellites()
                xxx

          [for each companion]:
            Star.createSatellites()
              [as above...]
        [get / set GasGiant]                   // rerunning due to timing issue
        Star.designateMainworld()
          [find highest pop Habitable]
          Habitable.completeUWP()
            UWP_ScoutsEx.completeUWP()
              UWP.generateGov()
              UWP.generateLaw()
              UWP.generateStarport()
              UWP.generateTech()
          [for every other Habitable]:
             Habitable.completeUWP()
               UWP_ScoutsEx.completeUWP()
                 UWP_ScoutsEx.generateSubordinateGov()
                 UWP_ScoutsEx.generateSubordinateLaw()
                 UWP_ScoutsEx.generateSubordinateStarport()
                 UWP_ScoutsEx.generateSubordinateTech()

// 'true' UWP exists from this point

        System.generateNavalBase()             // rerunning due to timing issue
        System.generateScoutBase()             // rerunning due to timing issue
        System_CT81.generateTradeClass()       // rerunning due to timing issue
        System_ScoutsEx.generateFacilities()
  createSummary()                              // timing is OK, post 'true' UWPs
    magnitudeFormatNumber()
    commaFormatList()
  calculateRoutes()                            // timing is OK, post 'true' UWPs

--------------------------
System
  ctors()
  generateTradeClass()
  generateUWP()
  addRoute()
  distanceToSystem()
  generateScoutBase()
  generateNavalBase()
  toString()
  listRoutes()
  asJSON()
System_CT81
  ctors()
  generateTradeClass()                         // OVERRIDE
  generateUWP()                                // OVERRIDE
  generateTravelZone()
  toString()                                   // OVERRIDE
  asJSON()                                     // OVERRIDE
System_ScoutsEx
  ctors()
  generateFacilities()
  toString()                                   // OVERRIDE
  asJSON()                                     // OVERRIDE
  [generateUWP()]                              // -- missing override?
--------------------------
Would it be better to have some sort of factory/builder class handling 
all the timing of events here, rather than confusing ctor chains? Could
greatly simplify what are essentially just data classes after they've been
built.

Alternatively, the root class for each of these little trees is the
data class. Subclasses override generation, but once complete, clients
can just talk to the root interface and eliminate a ton of casting
and visibility into exact types.
--------------------------
Random idea: should we add a common root class for all
these data classes that could provide services (or interface)
for functionality like to/from JSON? (Or maybe just an interface...)

Catalog the classes here:

Traveller 
Button
  Command                 // interface
  NewSubsector
  Load
  ChangeColors
  ChangeRules
  ButtonUtilities
ColorScheme               // asJSON() + ctor(JSONObject)
Coordinate                // asJSON() + ctor(JSONObject)
Dice
  DiceMock
Orbit                     // abstract  -- SHOULD have JSON functionality
  Empty
  Forbidden
  Null
  GasGiant
  Habitable               // interface
  Planet
  Planetoid
  Moon
  Ring
Polygon
Route                     // asJSON() + ctor(JSONObject)
Ruleset                   // -- SHOULD be subclassed
Screen                    // abstract
  Menu
  Display
Star                      // asJSON() + ctor(JSONObject)
Subsector                 // asJSON() + ctor(JSONObject)
SubsectorDisplay
System                    // asJSON() + ctor(JSONObject) -- SHOULD be absract
  System_CT81             // asJSON() + ctor(JSONObject)
  System_ScoutsEx         // asJSON() + ctor(JSONObject)
TestSuite
  HabitableZoneForG0VIs3
  DistanceBetweenSubsectorCornersIsThirteen
  SizeZeroWorldsHaveNoHydrosphere
  SizeZeroWorldsHaveNoAtmosphere
  UnoccupiedSystemsHaveNoUWP
  NavalBaseOnlyAtABStarports
  ScoutBaseOnlyAtABCDStarports
  NoRoutesToRedZones
  TestCase                // -- SHOULD be abstract ?
TextPanel
TradeClass
  TradeClass_CT81
UWP                       // asJSON() + ctor(JSONObject)
  UWP_CT81                // inherited.asJSON() + inherited.ctor(JSONObject)
  UWP_ScoutsEx            // inherited.asJSON() + inherited.ctor(JSONObject)
==========================================================
6/3/23

Scouts generation is feature complete. Time to circle back on app functionality,
code cleanup, and bugs. We'll start with the JSON save/load.

We currently have this JSON structure:

Systems [
  { Naval Base,
    Gas Giant,
    Occupied,
    Travel Zone,
    Coordinate
      { Column,
        Row },
    Scout Base,
    Primary
      { Companions [
         { Orbit,
           Class,
           Orbits [
             "String",
             ... ]},
          ... ]},
         Class,
         Orbits [
           "String",
           ... ]},
    Name,
    UWP
      { Law Level,
        Government,
        Tech Level,
        Starport,
        Size,
        Atmosphere,
        Population,
        Hydrographics }},
  ...]

// --------------------------
The corresponding code flow is:

Subsector.asJSON()
  [for each System]:
    System_ScoutsEx.asJSON()
      System_CT81.asJSON()
        System.asJSON()
          Coordinate.asJSON()   // "Coordinate"
            setInt              // "Column"
            setInt              // "Row"
          setBoolean            // "Occupied"
          setString             // "Name"              
          setBoolean            // "Naval Base"
          setBoolean            // "Scout Base"
          setBoolean            // "Gas Giant"
          UWP.asJSON()          // "UWP"     -- no overrides
            setString           // "Starport"
            setInt              // "Size"
            setInt              // "Atmosphere"
            setInt              // "Hydrographics"
            setInt              // "Population"
            setInt              // "Government"
            setInt              // "Law Level"
            setInt              // "Tech Level"
      setString                 // "Travel Zone"
    Star.asJSON()               // "Primary"
      setString                 // "Class"
      Star.asJSON()             // "Close Companion"
        ...
      [for each Companion]:     // "Companions"
        Star.asJSON()           // array entry
          ...
      [for each Orbit]:         // "Orbits"
        setString               // orbits entry
        ...
      setInt                    // "Orbit"   -- for non-primary entities  
// --------------------------

Obvious first candidate is the String representation for all non-Star
Orbit objects. These should be compound JSONObjects just like the rest. I've
kludged it so far by appending their own satellites to their toString()
representation, but that's not going to support loading.

Nothing in the Orbit hierarchy other than Star currently has asJSON().

6/9/23

That part is done - Orbit now has asJSON(), and it includes logic to handle
Habitable and Container variants. Just need to review fields on all objects
to make sure they're covered, and this bit is done.

Subsector -----------------------------------------
  String name;                                 ok
  String summary;                              ok
  [Ruleset ruleset]                            ok
  Dice roll;                                   n/a
  int vertCount;                               n/a
  int horzCount;                               n/a
  LinkedHashMap<Coordinate, System> systems; ------
    Polygon hex;                               n/a
    Coordinate coord; -----------------------------
      int column, row;                         ok
      int x, y, z;                             n/a
      float yOffset;                           n/a
      int startX;                              n/a 
      int startY;                              n/a
    Boolean occupied;                          ok
    UWP uwp; --------------------------------------
      char starport;                           ok
      int size;                                ok 
      int atmo;                                ok 
      int hydro;                               ok
      int pop;                                 ok
      int gov;                                 ok
      int law;                                 ok
      int tech;                                ok
      Dice roll;                               n/a
      Orbit planet;                            ??   only used during ctor, so n/a
    Boolean navalBase;                         ok
    Boolean scoutBase;                         ok
    Boolean gasGiant;                          ok
    TradeClass trade;                          n/a
    String name;                               ok
    ArrayList<Route> routes;                   n/a
    Dice roll;                                 n/a
    String travelZone;                         ok
    Star primary; ---------------------------------
      System parent;                           n/a
      Boolean primary;                         n/a
      char type;                               ok   combined as 'class'
      int typeRoll;                            n/a
      int decimal;                             ok   combined as 'class'
      int size;                                ok   combined as 'class'
      int sizeRoll;                            n/a
      Star closeCompanion;                     ok   should rethink companion listings
      String[] orbitalZones;                   n/a
      int gasGiantCount;                       ??   regenerate?
                                                    here and below from Orbit superclass
      Orbit barycenter;                        ??   regenerate?
      String name;                             ok   as 'class'
      int orbitNumber;                         ok   add this
      String orbitalZone;                      ok   add this
      Boolean captured;                        ok   add this
      float offsetOrbitNumber;                 ok   add this
      TreeMap<Float, Orbit> orbits; ---------------
        Orbit barycenter;                      ??   regenerate?
        String name;                           ok   as 'class'
        int orbitNumber;                       ok   add this
        String orbitalZone;                    ok   add this
        Boolean captured;                      ok   add this
        float offsetOrbitNumber;               ok   add this
        String size;                           ??   GasGiant subclass only
        UWP_ScoutsEx uwp; ------------------------- Planet/Planetoid subclasses only
          
        Boolean mainworld;                          Planet/Planetoid subclasses only
        ArrayList<String> facilities; ------------- Planet/Planetoid subclasses only
          [String facility]                    ok
        TreeMap<Float, Orbit> orbits;--------------

        Dice roll;                             n/a
      Dice roll;                               n/a
    Habitable mainworld;                       ??   regenerate?
    int gasGiantCount;                         ??   regenerate?
    Boolean militaryBase;                      ok   add this
  ArrayList<Route> routes; ------------------------
    System s1;                                 ok
    System s2;                                 ok
    int distance;                              n/a

5/10/23

Easy adds are done, and several others should be regenerated at load time, so 
we'll solve then. Seems like two remaining areas:

* Cross-references like mainworld, close companion and barycenter. To prevent 
  duplication, these should probably be a pointer into the orbits list. I 
  already removed the "companions" list for the same reason.

* Exact subclass for various orbits. In my initial version of this code path,
  we were using a "name" string in the orbit listing, and logic to build the 
  correct object on load.

Also, as we go through this, I'm spotting more instances where Star is 
divergent from all the other Orbit classes and reconciling - usually by 
eliminating the code in Star and merging it up. In general, all classes 
should rely on Orbit.asJSON() entirely, or call it via super in their 
own override and then add content.

--------------------------------------------------------
7/11/23

Preparing to implement the MegaTraveller ruleset. To get started, review
the creation process and note differences from Scouts - it's pretty close.
Likely handled via subclasses.

But also, reviewing the Star class, it's gotten pretty big - this might
be the time to separate out the creational methods into a Builder. Most 
of the code (and the most complicated logic) is only invoked on creation,
and is also likely where all the differences are.

Would be helpful if we had access controls in place - likely all private
methods are creational (or utility), and we could break out that way. But
unfortunately the Processing Inner Class model means everything is 
accessible, so have been lazy and not marked anything. Maybe a quick review
will help. (Same argument applies to fields - haven't been consistent with
getters/setters, and they can't be guaranteed encapsulated.)

====================
Sketch of the initial process flow:

new Subsector()
  ...
  ruleset.newSystem(...)
    new System_MTEx          // TO_DO, based on System_ScoutsEx
      primary = new Star()   // TO_DO, need an MT subclass
      primary.createSatellites()
      countGasGiants()
      mainworld = primary.designateMainworld()
      uwp = mainworld.getUWP()
      ...      

References		====================
			Star extends Orbit
			--------------------
Orbit, Star, UWP	System parent
Orbit, Star		Boolean primary
Orbit, Star, TestSuite	char type
Star			int typeRoll
Star, TestSuite		int decimal
Star, TestSuite		int size
Star			int sizeRoll
Star, System		Star closeCompanion
Orbit, Star, TestSuite	String[] orbitalZones
Star			int gasGiantCount
			--------------------
Star, System		Star(System _parent)
Star, System		Star(System _parent, JSONObject _json)
Star			Star(Orbit _barycenter, int _orbit, String _zone, System _parent)
Orbit, Star		Star(Orbit _barycenter, System _parent, JSONObject _json)
Star, TestSuite		Star(Boolean _primary, System _parent, String _s)
			--------------------
Star			Boolean isStar()
Star			Boolean orbitIsTooHot(int _num)
Star			Boolean orbitIsNull(int _num)
Star			Boolean orbitIsNullOrEmpty(int _num)
Star			Boolean orbitInsideStar(int _num)
Star, TestSuite		Boolean orbitIsForbidden(int _num)
Star			Boolean orbitIsInnerZone(int _num)
Star			Boolean orbitIsFar(int _num)
Star			Boolean orbitMaskedByCompanion(int _num)
			--------------------
Star			void createStar()
Star			char generateType()
Star			int generateSize()
Star			void spectralTypeFromString(String _s)
Star, System		String getSpectralType()
Star			String[] retrieveOrbitalZones()
   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 
Star, System		void createSatellites()
Star			int generateCompanionCount()
Star			int generateCompanionOrbit(int _iteration)
Star			int calculateMaxOrbits()
Star			void placeEmptyOrbits(int _maxOrbit)
Star			void placeForbiddenOrbits(int _maxOrbit)
Star			void placeCapturedPlanets()
Star			float generateCapturedOrbit()
Star			void placeGasGiants(int _maxOrbit)
Star			void placePlanetoidBelts(int _maxOrbit)
Star			void placePlanets(int _maxOrbit)
Star, System		Habitable designateMainworld()
Star			int getRandomUnassignedOrbit(int _maxOrbit)
Star			IntList availableOrbitsForGiants(int _maxOrbit)
Star			IntList availableOrbitsForPlanetoids(int _maxOrbit)
Star, System		ArrayList<Star> getCompanions()
Star			String sizeToString()
Star			int sizeFromString(String _s)
Star, System		String toString()
Star, System		JSONObject asJSON()
			====================

In this same vein, might be worthwhile to draw up some code metrics and look 
for hotspots. What is the size of each class? Of each method? At some point,
would also like to apply the analysis from "Your Code as a Crime Scene" to 
the repository history.

Another refactoring target: initially I was thinking Ruleset would become a 
polymorphic family - and it still might. But right now it is just maintaining
a single setting and a few queries, yet it keeps being reconstructed. When I 
added SubsectorDensity, that design works similarly without the ctor calls.
Push ruleset to the same model.


=====================
SubsectorDensity
  float value
  int current
  float[] values
  String[] labels
  ---------------
  SubsectorDensity()
  ---------------
  void next()
=====================

Traveller
  density = new SubsectorDensity()
Button
  density = new SubsectorDensity()

=====================
Ruleset
  String name
  int currentRules
  String[] rules
  ---------------
  Ruleset()
  Ruleset(String _rules)
  Ruleset(int _current)
  ---------------
  void next()
  Boolean supportsTravelZones()
  Boolean supportsStars()
  Boolean supportsDensity()
  System newSystem(Coordinate _coord, Float _density)
  system newSystem(JSONObject _json)
=====================

Traveller
  ruleset = new Ruleset()
Subsector
  ruleset = new Ruleset(_json.getString("Ruleset"))
Ruleset
  ruleset = new Ruleset(currentRules)

OK, this is done. Small tweak to Ruleset.next() and removal of the superfluous 
ctor and it now behaves like SubsectorDensity. Effectively a Singleton, we 
create once on startup (or again on load from JSON). Probably not worth the
effort to put in the actual pattern.

7/13/23

Returning to the Star interface... I've added a StarBuilder class to move 
methods to. Right now, each system creates a new one - uncertain if there 
should be a single global builder in the future, but this ought to work for 
now.

Most of the 'private' methods identified above are creational, and candidates 
to move. Some make sense as part of the ctor and can stay (Star -> createStar -> 
generateType/generateSize/retrieveOrbitalZone). But the others are concerned 
more with the composite structure, and that's what the builder helps with.

That second set starts from the createSatellites entry point. First issue - 
we get a NullPointerException from generateType() when we call it from the 
StarBuilder - need to untangle references here.

OK, sorted - the primary reference in the parent system hadn't been set. 
Solution is a bit of an ugly hack, this will probably get cleaned up as we 
move bits over to the builder.

