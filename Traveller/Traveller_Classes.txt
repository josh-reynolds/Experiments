4/20/23
Reviewing classes, esp. w.r.t. JSON representation.
Focusing on System for now as that's where most of the effort
is going (and outside this cluster classes are mostly app scaffolding).

                                          VERIFY JSON
=====================================     =================================
System
-------------------------------------
Polygon hex                                n/a - regenerate on load
Coordinate coord                           OK (JSONObject)
Boolean occupied                           OK (primitive)
UWP uwp                                    OK (JSONObject)
Boolean navalBase                          OK (primitive)
Boolean scoutBase                          OK (primitive)
Boolean gasGiant                           OK (primitive)
TradeClass trade                           n/a - regenerate on load
String name                                OK (primitive)
ArrayList<Route> routes                    n/a - regenerate from separate list
-------------------------------------
System(Coordinate)
System(JSONObject)

TradeClass generateTradeClass(UWP)
UWP generateUWP()
UWP generateUWP(JSONObject)
Boolean generateScoutBase()
Boolean generateNavalBase()

void addRoute(Route)
int distanceToSystem(System)
String listRoutes()

String toString()
JSONObject asJSON()
=====================================

=====================================
System_CT81 extends System
-------------------------------------
String travelZone                          OK (primitive)
-------------------------------------
System_CT81(Coordinate)
System_CT81(JSONObject)

TradeClass generateTradeClass(UWP)
UWP generateUWP()
UWP generateUWP(JSONObject)
String generateTravelZone()

String toString()
JSONObject asJSON()
=====================================

=====================================
System_ScoutsEx extends System_CT81
-------------------------------------
Star primary                               OK (JSONObject)
-------------------------------------
System_ScoutsEx(Coordinate)
System_ScoutsEx(JSONObject)

String toString()
JSONObject asJSON()
=====================================


=====================================
abstract Orbit
-------------------------------------
Orbit barycenter                           ??
String name                                ??
int orbitNumber                            OK (primitive on subclasses)
String orbitalZone                         ??

Habitable[] moons                          ??

Dice roll                                  n/a - regenerate on load
-------------------------------------
Orbit(Orbit, int, String)

void createSatellites(int)
int generateSatelliteSize()

Boolean isOrbitingClassM()
Boolean isInnerZone()
Boolean isHabitableZone()
Boolean isOuterZone()
Boolean isAtLeastTwoBeyondHabitable()

Boolean isStar()
Boolean isEmpty()
Boolean isForbidden()
Boolean isNull()
Boolean isGasGiant()
Boolean isPlanet()
Boolean isPlanetoid()
Boolean isMoon()
Boolean isRing()

String toString()
=====================================


// we are using 'star class' to pack three
// values into a string - should the fields change to match?
// just supply methods for when a client need to know type etc.

// also rename the 'get' methods - they look like accessors
// but are actually creational

// String unpacking alone may not be enough data -
// the orbitNumber needs to be added as well (special cases
// for primary and close companion - null & -1? - don't 
// like these 'magic numbers' though)

// we also have overlap/conflict between orbits & companion
// lists when loaded from JSON - fix!   ASSESS, companions is now a query

// companion might be better as a query against orbits[]  - DONE!
// and by extension could do the same for other categories of satellite
=====================================
Star extends Orbit                         
-------------------------------------
System parent                              n/a - regenerate on load
Boolean primary                            n/a - regenerate on load
int typeRoll                               n/a - only needed at creation time
int sizeRoll                               n/a - only needed at creation time

char type                                  OK (String unpacking)
int decimal                                OK (String unpacking)
int size                                   OK (String unpacking)

//ArrayList<Star> companions           OK (JSONArray - JSONObjects) DEPRECATED
Star closeCompanion                        OK (JSONObject)
Orbit[] orbits                             OK (JSONArray - Strings)
String[] orbitalZones                      OK - regenerate on load
int gasGiantCount                          TBD (probably regen on load)
-------------------------------------
Star(Boolean, System)
Star(Boolean, System, String)              DEPRECATE
Star(Boolean, System, JSONObject)

Boolean isStar()

char generateType()
int generateSize()
void classFromString(String)
String[] retrieveOrbitalZones()

void createSatellites()
int generateCompanionCount()
int generateCompanionOrbits()
int calculateMaxOrbits()
Orbit[] createOrbits(int, int)
void placeCompanions(int, int)
void placeNullOrbits()
void placeEmptyOrbits(int, int)
void placeForbiddenOrbits()
void placeCapturedPlanets()                STUB, needs some thought
void placeGasGiants()
void placePlanetoidBelts()
void placePlanets()
int getRandomNullOrbit()
IntList availableOrbitsForGiants()
IntList availableOrbitsForPlanetoids()

ArrayList<Star> getCompanions()

Boolean orbitIsTooHot(int)
Boolean orbitIsNull(int)
Boolean orbitIsNullOrEmpty(int)
Boolean orbitInsideStar(int)
Boolean orbitIsFar(int)
Boolean orbitMaskedByCompanion(int)

String sizeToString()
int sizeFromString()

String toString()
JSONObject asJSON()
=====================================

=====================================
Empty extends Orbit
-------------------------------------
-------------------------------------
Empty(Star, int, String)

Boolean isEmpty()
=====================================

// long term this one and Empty may merge together
// but for now it helps to visualize the algorithm steps
// (what if they had a 'memo' field instead?)
=====================================
Forbidden extends Orbit
-------------------------------------
-------------------------------------
Forbidden(Star, int, String)

Boolean isForbidden()
=====================================

// null object added to help build out the
// algorithm - should only exist while the
// system is being populated
// unclear if this will stay in the final design
=====================================
Null extends Orbit
-------------------------------------
-------------------------------------
Null(Star, int, String)

Boolean isNull()
=====================================

=====================================
GasGiant extends Orbit
-------------------------------------
String size                                TBD
-------------------------------------
GasGiant(Star, int, String)

Boolean isGasGiant()

int generateSatelliteCount()
int generateSatelliteSize()

String toString()                 overloaded to show moon list structure
=====================================

=====================================
interface Habitable
-------------------------------------
-------------------------------------
abstract UWP_ScoutsEx generateUWP()
=====================================

=====================================
Planet extends Orbit implements Habitable
-------------------------------------
UWP_ScoutsEx uwp                          ?? 
-------------------------------------
Planet(Orbit, int, String)

int generateSatelliteCount()
int generateSatelliteSize()
UWP_ScoutsEx generateUWP()

Boolean isPlanet()

String toString()                 overloaded to show moon list structure
=====================================

=====================================
Planetoid extends Orbit implements Habitable
-------------------------------------
UWP_ScoutsEx uwp                          ?? 
-------------------------------------
Planetoid(Orbit, int, String)

UWP_ScoutsEx generateUWP()

Boolean isPlanetoid()
=====================================

// still assessing whether following are
// useful - could also implement this
// via queries alone (class + barycenter.class)

=====================================
Moon extends Planet
-------------------------------------
-------------------------------------
Moon(Orbit, String)

Boolean isMoon()
=====================================

=====================================
Ring extends Planetoid
-------------------------------------
-------------------------------------
Ring(Orbit, String)

Boolean isRing()
=====================================


May need to rejigger the Orbit hierarchy. We have three kinds of things
in this tree that need to be mixed together:

- objects that orbit other objects (Orbit hierarchy)
- objects that can have other objects orbiting them (Orbit superclass)
- objects that have a UWP (Habitable superclass)

The first two are the Composite pattern. The contrast between Gas Giant & Planet
on the one hand, and Planet/Moon vs. Planetoid/Ring are the crux of
the matter.

There's shared implementation in both Orbit & Habitable that's worth keeping,
so can't just make one an interface without moving some things around. This 
could be motivation to pull all the query methods up from Habitable. Then
it could be an interface that exposes the UWP mechanics.

                      |   TRUE             |   FALSE          |
----------------------|--------------------|------------------|
Can have children     |   (Orbit)          |   (Habitable)    |
                      |   Star             |   Empty          |
                      |   Gas Giant        |   Forbidden      |
                      |   Planet           |   Null           |
                      |                    |   Planetoid      |
                      |                    |   Moon           |
                      |                    |   Ring           |
----------------------|--------------------|------------------|
Has a UWP             |   (Habitable)      |   (Orbit)        |
                      |   Planet           |   Star           |
                      |   Moon             |   Gas Giant      |
                      |   Planetoid        |   Empty          |
                      |   Ring             |   Forbidden      |
                      |                    |   Null           |
----------------------|--------------------|------------------|

(Orbit)
  Empty
  Forbidden
  Null
  Star
  GasGiant
  (Habitable)    ---- XXX now an interface
    Planet
    Planetoid
    Moon
    Ring

OK, trying this out. Habitable is now an interface used by
Planet & Planetoid.

5/6/23

Reviewed Composite and have some thoughts about cleaning this up. Motivation
is the "find the mainworld" code, which would be much simpler if we could 
walk through the tree uniformly.

In addition to the muddled hierarchy described above, the collections are
implemented differently:

- Stars have an array of Orbits
- Orbits have a TreeMap of Habitables (this isn't used by Stars,
    only by GasGiants + Planets)

So - I think we want a TreeMap of Orbits used by all composite classes.
(Added benefit: the TreeMap would allow Float indices, so we could
handle Captured Planets too.)

In the pattern terminology, the classes are:

Component - (Orbit)
Composite - Star, GasGiant, Planet
Leaf      - Empty, Forbidden, Null, Planetoid, Moon, Ring

(Habitable) as already noted is orthogonal to this structure. It means "has
a UWP" and is an interface implemented by Planet/Moon/Planetoid/Ring.


=========================================
5/26/23

Above reworking is essentially complete (and Scouts is nearly feature complete).
Lots of technical debt and no doubt bugs to handle from here. Exploring the space 
below.


-------------------------------------------
Scenario: NEW, rules == "Scouts (Extended)"
-------------------------------------------

REVIEW for overrides/polymorphic calls

new Subsector()
  [for each coordinate]: 
    ruleset.newSystem()
      System_ScoutsEx.ctor()
        System_CT81.ctor()
          System.ctor()
            [UI/utility stuff]
            [set / if occupied]:
              System_CT81.generateUWP()        // overridden, timing issue, is 'rerun'
                UWP_CT81.ctor()
              System.generateNavalBase()       // timing issue, is rerun
              System.generateScoutBase()       // timing issue, is rerun
              [set / if GasGiant]              // timing issue, is rerun
              System_CT81.generateTradeClass() // overridden, timing issue, is rerun
                TradeClass_CT81.ctor()
              [set name]
              [initialize routes list]
          System_CT81.generateTravelZone()     // -- timing issue, need to rerun
        Star.ctor()
          Orbit.ctor()
          Star.generateType()
          Star.generateSize()
          Star.retrieveOrbitalZones()
        Star.createSatellites()
          Star.generateCompanionCount()
          [for each companion]:
            Star.ctor()
            Star.generateCompanionOrbits()
          Star.calculateMaxOrbits()
          Star.placeNullOrbits()
            Null.ctor()
              Orbit.ctor()
          Star.fillEmptyOrbits()
            Empty.ctor()
              Orbit.ctor()
          Star.placeEmptyOrbits()
            Star.getRandomUnassignedOrbit()
            Empty.ctor()
              Orbit.ctor()
          Star.placeForbiddenOrbits()
            Forbidden.ctor()
              Orbit.ctor()
          Star.placeCapturedPlanets()          // still just a stub
          Star.placeGasGiants()
            Star.availableOrbitsForGiants()
            GasGiant.ctor()
              Orbit.ctor()
              GasGiant.generateSatelliteCount()
              Orbit.createSatellites()
                xxx

          Star.placePlanetoidBelts()
            Star.availableOrbitsForPlanetoids()
            Planetoid.ctor()
              Orbit.ctor()
              Planetoid.generateUWP()
                UWP_ScoutsEx.ctor()
                  UWP_ScoutsEx.generateSize()        // override
                  UWP_ScoutsEx.generateAtmo()        // override
                  UWP_ScoutsEx.generateHydro()       // override
                  UWP_ScoutsEx.generatePop()         // override
          Star.placePlanets()
            Planet.ctor()
              Orbit.ctor()
              Planet.generateUWP()
                UWP_ScoutsEx.ctor()
                  UWP_ScoutsEx.generateSize()        // override
                  UWP_ScoutsEx.generateAtmo()        // override
                  UWP_ScoutsEx.generateHydro()       // override
                  UWP_ScoutsEx.generatePop()         // override
              Planet.generateSatelliteCount()
              Orbit.createSatellites()
                xxx

          [for each companion]:
            Star.createSatellites()
              [as above...]
        [get / set GasGiant]                   // rerunning due to timing issue
        Star.designateMainworld()
          [find highest pop Habitable]
          Habitable.completeUWP()
            UWP_ScoutsEx.completeUWP()
              UWP.generateGov()
              UWP.generateLaw()
              UWP.generateStarport()
              UWP.generateTech()
          [for every other Habitable]:
             Habitable.completeUWP()
               UWP_ScoutsEx.completeUWP()
                 UWP_ScoutsEx.generateSubordinateGov()
                 UWP_ScoutsEx.generateSubordinateLaw()
                 UWP_ScoutsEx.generateSubordinateStarport()
                 UWP_ScoutsEx.generateSubordinateTech()

// 'true' UWP exists from this point

        System.generateNavalBase()             // rerunning due to timing issue
        System.generateScoutBase()             // rerunning due to timing issue
        System_CT81.generateTradeClass()       // rerunning due to timing issue
        System_ScoutsEx.generateFacilities()
  createSummary()                              // timing is OK, post 'true' UWPs
    magnitudeFormatNumber()
    commaFormatList()
  calculateRoutes()                            // timing is OK, post 'true' UWPs

--------------------------
System
  ctors()
  generateTradeClass()
  generateUWP()
  addRoute()
  distanceToSystem()
  generateScoutBase()
  generateNavalBase()
  toString()
  listRoutes()
  asJSON()
System_CT81
  ctors()
  generateTradeClass()                         // OVERRIDE
  generateUWP()                                // OVERRIDE
  generateTravelZone()
  toString()                                   // OVERRIDE
  asJSON()                                     // OVERRIDE
System_ScoutsEx
  ctors()
  generateFacilities()
  toString()                                   // OVERRIDE
  asJSON()                                     // OVERRIDE
  [generateUWP()]                              // -- missing override?
--------------------------
Would it be better to have some sort of factory/builder class handling 
all the timing of events here, rather than confusing ctor chains? Could
greatly simplify what are essentially just data classes after they've been
built.

Alternatively, the root class for each of these little trees is the
data class. Subclasses override generation, but once complete, clients
can just talk to the root interface and eliminate a ton of casting
and visibility into exact types.
--------------------------
Random idea: should we add a common root class for all
these data classes that could provide services (or interface)
for functionality like to/from JSON? (Or maybe just an interface...)

Catalog the classes here:

Traveller 
Button
  Command                 // interface
  NewSubsector
  Load
  ChangeColors
  ChangeRules
  ButtonUtilities
ColorScheme               // asJSON() + ctor(JSONObject)
Coordinate                // asJSON() + ctor(JSONObject)
Dice
  DiceMock
Orbit                     // abstract  -- SHOULD have JSON functionality
  Empty
  Forbidden
  Null
  GasGiant
  Habitable               // interface
  Planet
  Planetoid
  Moon
  Ring
Polygon
Route                     // asJSON() + ctor(JSONObject)
Ruleset                   // -- SHOULD be subclassed
Screen                    // abstract
  Menu
  Display
Star                      // asJSON() + ctor(JSONObject)
Subsector                 // asJSON() + ctor(JSONObject)
SubsectorDisplay
System                    // asJSON() + ctor(JSONObject) -- SHOULD be absract
  System_CT81             // asJSON() + ctor(JSONObject)
  System_ScoutsEx         // asJSON() + ctor(JSONObject)
TestSuite
  HabitableZoneForG0VIs3
  DistanceBetweenSubsectorCornersIsThirteen
  SizeZeroWorldsHaveNoHydrosphere
  SizeZeroWorldsHaveNoAtmosphere
  UnoccupiedSystemsHaveNoUWP
  NavalBaseOnlyAtABStarports
  ScoutBaseOnlyAtABCDStarports
  NoRoutesToRedZones
  TestCase                // -- SHOULD be abstract ?
TextPanel
TradeClass
  TradeClass_CT81
UWP                       // asJSON() + ctor(JSONObject)
  UWP_CT81                // inherited.asJSON() + inherited.ctor(JSONObject)
  UWP_ScoutsEx            // inherited.asJSON() + inherited.ctor(JSONObject)
==========================================================
6/3/23

Scouts generation is feature complete. Time to circle back on app functionality,
code cleanup, and bugs. We'll start with the JSON save/load.

We currently have this JSON structure:

Systems [
  { Naval Base,
    Gas Giant,
    Occupied,
    Travel Zone,
    Coordinate
      { Column,
        Row },
    Scout Base,
    Primary
      { Companions [
         { Orbit,
           Class,
           Orbits [
             "String",
             ... ]},
          ... ]},
         Class,
         Orbits [
           "String",
           ... ]},
    Name,
    UWP
      { Law Level,
        Government,
        Tech Level,
        Starport,
        Size,
        Atmosphere,
        Population,
        Hydrographics }},
  ...]

// --------------------------
The corresponding code flow is:

Subsector.asJSON()
  [for each System]:
    System_ScoutsEx.asJSON()
      System_CT81.asJSON()
        System.asJSON()
          Coordinate.asJSON()   // "Coordinate"
            setInt              // "Column"
            setInt              // "Row"
          setBoolean            // "Occupied"
          setString             // "Name"              
          setBoolean            // "Naval Base"
          setBoolean            // "Scout Base"
          setBoolean            // "Gas Giant"
          UWP.asJSON()          // "UWP"     -- no overrides
            setString           // "Starport"
            setInt              // "Size"
            setInt              // "Atmosphere"
            setInt              // "Hydrographics"
            setInt              // "Population"
            setInt              // "Government"
            setInt              // "Law Level"
            setInt              // "Tech Level"
      setString                 // "Travel Zone"
    Star.asJSON()               // "Primary"
      setString                 // "Class"
      Star.asJSON()             // "Close Companion"
        ...
      [for each Companion]:     // "Companions"
        Star.asJSON()           // array entry
          ...
      [for each Orbit]:         // "Orbits"
        setString               // orbits entry
        ...
      setInt                    // "Orbit"   -- for non-primary entities  
// --------------------------

Obvious first candidate is the String representation for all non-Star
Orbit objects. These should be compound JSONObjects just like the rest. I've
kludged it so far by appending their own satellites to their toString()
representation, but that's not going to support loading.

Nothing in the Orbit hierarchy other than Star currently has asJSON().

6/9/23

That part is done - Orbit now has asJSON(), and it includes logic to handle
Habitable and Container variants. Just need to review fields on all objects
to make sure they're covered, and this bit is done.

Subsector -----------------------------------------
  String name;                                 ok
  String summary;                              ok
  [Ruleset ruleset]                            ok
  Dice roll;                                   n/a
  int vertCount;                               n/a
  int horzCount;                               n/a
  LinkedHashMap<Coordinate, System> systems; ------
    Polygon hex;                               n/a
    Coordinate coord; -----------------------------
      int column, row;                         ok
      int x, y, z;                             n/a
      float yOffset;                           n/a
      int startX;                              n/a 
      int startY;                              n/a
    Boolean occupied;                          ok
    UWP uwp; --------------------------------------
      char starport;                           ok
      int size;                                ok 
      int atmo;                                ok 
      int hydro;                               ok
      int pop;                                 ok
      int gov;                                 ok
      int law;                                 ok
      int tech;                                ok
      Dice roll;                               n/a
      Orbit planet;                            ??   only used during ctor, so n/a
    Boolean navalBase;                         ok
    Boolean scoutBase;                         ok
    Boolean gasGiant;                          ok
    TradeClass trade;                          n/a
    String name;                               ok
    ArrayList<Route> routes;                   n/a
    Dice roll;                                 n/a
    String travelZone;                         ok
    Star primary; ---------------------------------
      System parent;                           n/a
      Boolean primary;                         n/a
      char type;                               ok   combined as 'class'
      int typeRoll;                            n/a
      int decimal;                             ok   combined as 'class'
      int size;                                ok   combined as 'class'
      int sizeRoll;                            n/a
      Star closeCompanion;                     ok   should rethink companion listings
      String[] orbitalZones;                   n/a
      int gasGiantCount;                       ??   regenerate?
                                                    here and below from Orbit superclass
      Orbit barycenter;                        ??   regenerate?
      String name;                             ok   as 'class'
      int orbitNumber;                         ok   add this
      String orbitalZone;                      ok   add this
      Boolean captured;                        ok   add this
      float offsetOrbitNumber;                 ok   add this
      TreeMap<Float, Orbit> orbits; ---------------
        Orbit barycenter;                      ??   regenerate?
        String name;                           ok   as 'class'
        int orbitNumber;                       ok   add this
        String orbitalZone;                    ok   add this
        Boolean captured;                      ok   add this
        float offsetOrbitNumber;               ok   add this
        String size;                           ??   GasGiant subclass only
        UWP_ScoutsEx uwp; ------------------------- Planet/Planetoid subclasses only
          
        Boolean mainworld;                          Planet/Planetoid subclasses only
        ArrayList<String> facilities; ------------- Planet/Planetoid subclasses only
          [String facility]                    ok
        TreeMap<Float, Orbit> orbits;--------------

        Dice roll;                             n/a
      Dice roll;                               n/a
    Habitable mainworld;                       ??   regenerate?
    int gasGiantCount;                         ??   regenerate?
    Boolean militaryBase;                      ok   add this
  ArrayList<Route> routes; ------------------------
    System s1;                                 ok
    System s2;                                 ok
    int distance;                              n/a

5/10/23

Easy adds are done, and several others should be regenerated at load time, so 
we'll solve then. Seems like two remaining areas:

* Cross-references like mainworld, close companion and barycenter. To prevent 
  duplication, these should probably be a pointer into the orbits list. I 
  already removed the "companions" list for the same reason.

* Exact subclass for various orbits. In my initial version of this code path,
  we were using a "name" string in the orbit listing, and logic to build the 
  correct object on load.

Also, as we go through this, I'm spotting more instances where Star is 
divergent from all the other Orbit classes and reconciling - usually by 
eliminating the code in Star and merging it up. In general, all classes 
should rely on Orbit.asJSON() entirely, or call it via super in their 
own override and then add content.

--------------------------------------------------------
7/11/23

Preparing to implement the MegaTraveller ruleset. To get started, review
the creation process and note differences from Scouts - it's pretty close.
Likely handled via subclasses.

But also, reviewing the Star class, it's gotten pretty big - this might
be the time to separate out the creational methods into a Builder. Most 
of the code (and the most complicated logic) is only invoked on creation,
and is also likely where all the differences are.

Would be helpful if we had access controls in place - likely all private
methods are creational (or utility), and we could break out that way. But
unfortunately the Processing Inner Class model means everything is 
accessible, so have been lazy and not marked anything. Maybe a quick review
will help. (Same argument applies to fields - haven't been consistent with
getters/setters, and they can't be guaranteed encapsulated.)

====================
Sketch of the initial process flow:

new Subsector()
  ...
  ruleset.newSystem(...)
    new System_MTEx          // TO_DO, based on System_ScoutsEx
      primary = new Star()   // TO_DO, need an MT subclass
      primary.createSatellites()
      countGasGiants()
      mainworld = primary.designateMainworld()
      uwp = mainworld.getUWP()
      ...      

References		====================
			Star extends Orbit
			--------------------
Orbit, Star, UWP	System parent
Orbit, Star		Boolean primary
Orbit, Star, TestSuite	char type
Star			int typeRoll
Star, TestSuite		int decimal
Star, TestSuite		int size
Star			int sizeRoll
Star, System		Star closeCompanion
Orbit, Star, TestSuite	String[] orbitalZones
Star			int gasGiantCount
			--------------------
Star, System		Star(System _parent)
Star, System		Star(System _parent, JSONObject _json)
Star			Star(Orbit _barycenter, int _orbit, String _zone, System _parent)
Orbit, Star		Star(Orbit _barycenter, System _parent, JSONObject _json)
Star, TestSuite		Star(Boolean _primary, System _parent, String _s)
			--------------------
Star			Boolean isStar()
Star			Boolean orbitIsTooHot(int _num)
Star			Boolean orbitIsNull(int _num)
Star			Boolean orbitIsNullOrEmpty(int _num)
Star			Boolean orbitInsideStar(int _num)
Star, TestSuite		Boolean orbitIsForbidden(int _num)
Star			Boolean orbitIsInnerZone(int _num)
Star			Boolean orbitIsFar(int _num)
Star			Boolean orbitMaskedByCompanion(int _num)
			--------------------
Star			void createStar()
Star			char generateType()
Star			int generateSize()
Star			void spectralTypeFromString(String _s)
Star, System		String getSpectralType()
Star			String[] retrieveOrbitalZones()
   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 
Star, System		void createSatellites()
Star			int generateCompanionCount()
Star			int generateCompanionOrbit(int _iteration)
Star			int calculateMaxOrbits()
Star			void placeEmptyOrbits(int _maxOrbit)
Star			void placeForbiddenOrbits(int _maxOrbit)
Star			void placeCapturedPlanets()
Star			float generateCapturedOrbit()
Star			void placeGasGiants(int _maxOrbit)
Star			void placePlanetoidBelts(int _maxOrbit)
Star			void placePlanets(int _maxOrbit)
Star, System		Habitable designateMainworld()
Star			int getRandomUnassignedOrbit(int _maxOrbit)
Star			IntList availableOrbitsForGiants(int _maxOrbit)
Star			IntList availableOrbitsForPlanetoids(int _maxOrbit)
Star, System		ArrayList<Star> getCompanions()
Star			String sizeToString()
Star			int sizeFromString(String _s)
Star, System		String toString()
Star, System		JSONObject asJSON()
			====================

In this same vein, might be worthwhile to draw up some code metrics and look 
for hotspots. What is the size of each class? Of each method? At some point,
would also like to apply the analysis from "Your Code as a Crime Scene" to 
the repository history.

Another refactoring target: initially I was thinking Ruleset would become a 
polymorphic family - and it still might. But right now it is just maintaining
a single setting and a few queries, yet it keeps being reconstructed. When I 
added SubsectorDensity, that design works similarly without the ctor calls.
Push ruleset to the same model.


=====================
SubsectorDensity
  float value
  int current
  float[] values
  String[] labels
  ---------------
  SubsectorDensity()
  ---------------
  void next()
=====================

Traveller
  density = new SubsectorDensity()
Button
  density = new SubsectorDensity()

=====================
Ruleset
  String name
  int currentRules
  String[] rules
  ---------------
  Ruleset()
  Ruleset(String _rules)
  Ruleset(int _current)
  ---------------
  void next()
  Boolean supportsTravelZones()
  Boolean supportsStars()
  Boolean supportsDensity()
  System newSystem(Coordinate _coord, Float _density)
  system newSystem(JSONObject _json)
=====================

Traveller
  ruleset = new Ruleset()
Subsector
  ruleset = new Ruleset(_json.getString("Ruleset"))
Ruleset
  ruleset = new Ruleset(currentRules)

OK, this is done. Small tweak to Ruleset.next() and removal of the superfluous 
ctor and it now behaves like SubsectorDensity. Effectively a Singleton, we 
create once on startup (or again on load from JSON). Probably not worth the
effort to put in the actual pattern.

7/13/23

Returning to the Star interface... I've added a StarBuilder class to move 
methods to. Right now, each system creates a new one - uncertain if there 
should be a single global builder in the future, but this ought to work for 
now.

Most of the 'private' methods identified above are creational, and candidates 
to move. Some make sense as part of the ctor and can stay (Star -> createStar -> 
generateType/generateSize/retrieveOrbitalZone). But the others are concerned 
more with the composite structure, and that's what the builder helps with.

That second set starts from the createSatellites entry point. First issue - 
we get a NullPointerException from generateType() when we call it from the 
StarBuilder - need to untangle references here.

OK, sorted - the primary reference in the parent system hadn't been set. 
Solution is a bit of an ugly hack, this will probably get cleaned up as we 
move bits over to the builder.

7/14/23

Testing the waters by moving part of createSatellites() over to the builder. 
The first stage creates companions. As part of this, I'm encapsulating 
the primary field on Star.

On the surface this is innocuous, and appears to run correctly. However, I'm
seeing some odd output in the console. The "Determing X for Star" lines all
reference the *next* system, including companion stars. I don't think the 
encapsulation change did this - probably was from the insertion of StarBuilder - 
so will proceed with this, then trace and figure it out. Likely to be a bit 
of jankiness as this gets shifted over anyway, so not entirely unexpected.
(Ought to review test coverage as we go too, of course...)

On review (and some debugging spew), I think this is just due to folding 
createSatellites() into the builder.newStar() call. Will need to shuffle the 
output ordering, but that will probably all shake out naturally during the 
progress of this refactoring.

7/19/23

Finished moving Star creational methods over to StarBuilder. Fairly straightforward.
One wrinkle I noticed is we no longer check for companions of Far companions, 
so will need to fix that. Quaternary systems were rare, but possible previously.

Some of these blend into methods in the Orbit root class, and next opportunity 
is probably to make the "StarBuilder" into an "OrbitBuilder." The pattern helps 
most with assembly of a complex Composite, like we have here.

As we do that, some of the special casing in the Star procedure can be merged 
into a more generalized Orbit procedure (with appropriate steps by type, of 
course). The builder should take advantage of the Composite, and walk its way
through. This merger will probably help clean up the Far companion issue noted 
above.

9/13/23

The Builder pattern has proven useful. As hinted above, StarBuilder was
renamed to OrbitBuilder to reflect its true scope. I also applied the pattern
to UWP to unsnarl some of the problems in its inheritance chain. Since the 
last updates I also completed the core MegaTraveller ruleset, and added a 
'player character' ship class with rudimentary UI and console output. And 
I have a side project experimenting with visualization of a Scouts 'with
orbits' System that may fold in as a UI panel in the main app.

Besides Builder, a couple other learnings:

* I've probably been hitting the gnarlier issues because of violation of
constructor best practice. They are doing too much, and things go sideways
especially when invoking super. This is exactly why Builder is so helpful here.
Discussion below for the latest; this might bear some overall review and 
redesign across the entire application.

* It's apparent that there are two families of ruleset: 'simple Systems,'
and 'Systems with Orbits.' The first family starts with CT77, and the 
second with Scouts. Possibly more to discover later (like GURPS, maybe?),
but I suspect most of the remaining variants will follow one of these two
models in broad strokes. Crossing lines between these families during 
inheritance has been the source of a lot of the issues discussed above.

So, continuing from that - latest class needing some attention is System 
itself. Not yet pulling out the Builder pattern, but if need be that might
be the way to resolve the problems. But first we'll start by untangling
the constructors.

I was adding a TradeClass variant for MegaTraveller (and along the way noticed
Scouts also needs some specialization). Because of size 'S' planets (added
in Scouts), the Asteroid classification needs to know whether it is applying
to a Planet or a Planetoid. The 'isPlanet' flag lives on UWP_ScoutsEx, so
this needed a downcast. Problem is, during the super constructor call, we're
handling a plain UWP and the cast fails.

But that super call itself is the issue. For Scouts, it calls up the constructor
inheritance chain, and creates a dummy UWP and other values that are later
overwritten. This is because under the Scouts family, until you create all
Orbits and designate a mainworld, you don't know what values the System as a 
whole has.

I arrived at this by applying somethign like the Template Method pattern. The
super constructor outlines a series of steps, specified in methods. Child 
classes then override the methods to specialize. But when the child radically
alters the template, we need to do something else.

So... we should break up these constructors. Provide a simple path for creating
the 'internal super' with only common pieces applicable to ALL subclasses (and/or
valid as null). Then have either extension constructors or another approach
to apply the templates.

Analyzing the current classes we have:

System----------------------------------------
  UWPBuilder ub = ruleset.newUWPBuilder(); 
  ub.newUWPFor(this);
  navalBase = generateNavalBase();
  scoutBase = generateScoutBase();
  if (roll.two() <= 9){ gasGiant = true; }
  trade = generateTradeClass(uwp);
  name = lines[floor(random(lines.length))];
  routes = new ArrayList<Route>();

System_CT81 extends System--------------------
  travelZone = generateTravelZone();

System_ScoutsEx extends System_CT81-----------
  builder = ruleset.newOrbitBuilder();
  builder.newStar(this);
  countGasGiants();     
  uwp = mainworld.getUWP();         
  navalBase = generateNavalBase();
  scoutBase = generateScoutBase();      
  trade = generateTradeClass(uwp);
  travelZone = generateTravelZone();  
  generateFacilities();

System_MT extends System_ScoutsEx-------------
  (just calls super)

System fields across rulesets look like:

[77][81][SC][MT]
----------------
[OK][OK][--][--] System-level UWP
[OK][OK][RE][RE] Naval Base
[OK][OK][RE][RE] Scout Base
[OK][OK][RE][RE] Gas Giants
[OK][OK][RE][RE] Trade Class
[OK][OK][??][??] Name
[OK][OK][??][??] Routes
[--][OK][RE][RE] Travel Zone
[--][--][OK][OK] Orbits
[--][--][OK][OK] Mainworld UWP
[--][--][OK][OK] Facilities

-- : does not apply
OK : OK implementation via class constructor or super
RE : dummy implemenation in super; regenerated after
?? : only implemented in super

Initial simple approach is to add a 'default constructor' for System that
just takes a coordinate, and use this in super calls. System itself can
use 'this', then continue with the specialized pieces (invoked if 
occupied==true).

Did this, and now we're missing out on Name and Routes since we only got 
this from super. Need to duplicate that downward. Refactor any duplication
later once we get this working.

(One other note: to prepare for these changes, I already moved the occupied
calculation up to subsector. Previously we passed density in, and did the 
check in the System ctor. This class doesn't need to know anything about
that concept, so it more appropriately belongs in Subsector - and moving 
it simplifies this constructor cleanup effort.)

---------------------------------------
10/8/23

Since the last update I:

* Reviewed the extensive MegaTraveller errata and incorporated (almost) all
changes. A couple I disagree with, and punted on others. Comments and TO_DOs
in all cases.

* Added SubsectorTraffic class to handle feature introduced in MT. Also wired
this through the UI, much like SubsectorDensity (follows same model).

* General refactoring and cleanup to facilitate the above.

* Added MT system-level data points: population multiplier + planetoid count. 
Also wired these through the new MT-style system line, and the subsector
summary output.

* Added MT prose homeworld descriptions.

* Finally refactored away all the switch statements in Ruleset. It's now
polymorphic. Motivation was looking ahead to T:NE and dreading updating all
those cases. Hopefully adding a new ruleset is streamlined now.

In that vein, I took a quick stab at the T:NE ruleset. Base class is indeed
very simple. Walking through the creational events not so much, though, so
thinking about how to make this easier too.

(Quick aside: this project is up to 5058 lines, including comments. Use
powershell: type *.pde | Measure-Object -line)

I think it may be time to diagram all the pieces. 

Also, one small source of confusion is when a given ruleset makes no changes 
from its predecessor, and thus uses the same class (like how MegaTraveller 
subclasses Subsector, but CT81 + Scouts use the same class as CT77). 

Considering adding dummy classes that just wrap super to make this more
transparent and easy to see an entire family/ruleset. And may want to tweak
the names of some of the base classes, as they're really the initial CT77
implementation, and usually not a generic entity.

So, for T:NE, here's a quick review of the creation call stack when pressing
the 'New' button:

Button.run()
  ruleset.newSubsector()
    new Subsector_MT()
      ruleset.newSystem()      
        new System_MT()
          super()
            ruleset.newOrbitBuilder().newStar() (changing to newPrimary())
              ruleset.newStar()
                new Star_MT()
                  createStar()
              createCompanionsFor()
                generateCompanionCountFor()
                generateCompanionOrbitFor()
                ruleset.newStar()
                  new Star_MT()
                    createStar()
              createSatellitesFor()
                calculateMaxOrbitsFor()
                placeEmptyOrbitsFor()
                placeForbiddenOrbitsFor()
                placeCapturedPlanetsFor()
                placeGasGiantsFor()
                placePlanetoidBeltsFor()
                placePlanetsFor()
              designateMainworldFor()
                Habitable.completeUWP()

10/9/23

Step-by-step mapping of T:NE procedure and corresponding methods.

1) System Presence - Subsector ctor, using values in SubsectorDensity
    same as MegaTraveller
2) System Details (no procedure here)
3) System Nature - OrbitBuilder.generateCompanionCountFor()
    same as MegaTraveller
4) Primary Star Type and Size - Star_MT.createStar() -> generateType(), generateSize()
    Type same as MegaTraveller
    Size same as MegaTraveller
5) Decimal Classification - Star_MT.createStar()
    T:NE slightly changes handling of K* IV stars, here in decimal rather
     than during generateSize()
    Also omits the special errata handling in createStar() (which forced
     A/F/G size II/III stars to V)
6) Companion Star Type and Size - Star_MT.createStar() -> generateType(), generateSize()
    T:NE changes the Type distribution for companions, need override
    same story for Size distribution and creation of D-class stars
7) Companion Orbit - OrbitBuilder.generateCompanionOrbitFor()
    same as MegaTraveller
8) Far Companion? - go to 9 else go to 11
9) Far Orbit - OrbitBuilder_MT.farOrbits()
    T:NE reverts to Scouts procedure
10) Additional Stars - this may have been broken during MT implementation,
     need to trace through

Looks like Star Type/Size is a good place to start unpacking things.

10/14/23

Working through T:NE, looks mostly copy-pasted from MegaTraveller, very minor
changes. Unfortunately they copied from pre-errata MT so it has the same
omissions and typos. In most cases I am assuming the errata should apply 
and using the 'fixed' MT methods.

