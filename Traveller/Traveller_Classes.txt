4/20/23
Reviewing classes, esp. w.r.t. JSON representation.
Focusing on System for now as that's where most of the effort
is going (and outside this cluster classes are mostly app scaffolding).

                                          VERIFY JSON
=====================================     =================================
System
-------------------------------------
Polygon hex                                n/a - regenerate on load
Coordinate coord                           OK (JSONObject)
Boolean occupied                           OK (primitive)
UWP uwp                                    OK (JSONObject)
Boolean navalBase                          OK (primitive)
Boolean scoutBase                          OK (primitive)
Boolean gasGiant                           OK (primitive)
TradeClass trade                           n/a - regenerate on load
String name                                OK (primitive)
ArrayList<Route> routes                    n/a - regenerate from separate list
-------------------------------------
System(Coordinate)
System(JSONObject)

TradeClass generateTradeClass(UWP)
UWP generateUWP()
UWP generateUWP(JSONObject)
Boolean generateScoutBase()
Boolean generateNavalBase()

void addRoute(Route)
int distanceToSystem(System)
String listRoutes()

String toString()
JSONObject asJSON()
=====================================

=====================================
System_CT81 extends System
-------------------------------------
String travelZone                          OK (primitive)
-------------------------------------
System_CT81(Coordinate)
System_CT81(JSONObject)

TradeClass generateTradeClass(UWP)
UWP generateUWP()
UWP generateUWP(JSONObject)
String generateTravelZone()

String toString()
JSONObject asJSON()
=====================================

=====================================
System_ScoutsEx extends System_CT81
-------------------------------------
Star primary                               OK (JSONObject)
-------------------------------------
System_ScoutsEx(Coordinate)
System_ScoutsEx(JSONObject)

String toString()
JSONObject asJSON()
=====================================


=====================================
abstract Orbit
-------------------------------------
Orbit barycenter                           ??
String name                                ??
int orbitNumber                            OK (primitive on subclasses)
String orbitalZone                         ??

Habitable[] moons                          ??

Dice roll                                  n/a - regenerate on load
-------------------------------------
Orbit(Orbit, int, String)

void createSatellites(int)
int generateSatelliteSize()

Boolean isOrbitingClassM()
Boolean isInnerZone()
Boolean isHabitableZone()
Boolean isOuterZone()
Boolean isAtLeastTwoBeyondHabitable()

Boolean isStar()
Boolean isEmpty()
Boolean isForbidden()
Boolean isNull()
Boolean isGasGiant()
Boolean isPlanet()
Boolean isPlanetoid()
Boolean isMoon()
Boolean isRing()

String toString()
=====================================


// we are using 'star class' to pack three
// values into a string - should the fields change to match?
// just supply methods for when a client need to know type etc.

// also rename the 'get' methods - they look like accessors
// but are actually creational

// String unpacking alone may not be enough data -
// the orbitNumber needs to be added as well (special cases
// for primary and close companion - null & -1? - don't 
// like these 'magic numbers' though)

// we also have overlap/conflict between orbits & companion
// lists when loaded from JSON - fix!   ASSESS, companions is now a query

// companion might be better as a query against orbits[]  - DONE!
// and by extension could do the same for other categories of satellite
=====================================
Star extends Orbit                         
-------------------------------------
System parent                              n/a - regenerate on load
Boolean primary                            n/a - regenerate on load
int typeRoll                               n/a - only needed at creation time
int sizeRoll                               n/a - only needed at creation time

char type                                  OK (String unpacking)
int decimal                                OK (String unpacking)
int size                                   OK (String unpacking)

//ArrayList<Star> companions           OK (JSONArray - JSONObjects) DEPRECATED
Star closeCompanion                        OK (JSONObject)
Orbit[] orbits                             OK (JSONArray - Strings)
String[] orbitalZones                      OK - regenerate on load
int gasGiantCount                          TBD (probably regen on load)
-------------------------------------
Star(Boolean, System)
Star(Boolean, System, String)              DEPRECATE
Star(Boolean, System, JSONObject)

Boolean isStar()

char generateType()
int generateSize()
void classFromString(String)
String[] retrieveOrbitalZones()

void createSatellites()
int generateCompanionCount()
int generateCompanionOrbits()
int calculateMaxOrbits()
Orbit[] createOrbits(int, int)
void placeCompanions(int, int)
void placeNullOrbits()
void placeEmptyOrbits(int, int)
void placeForbiddenOrbits()
void placeCapturedPlanets()                STUB, needs some thought
void placeGasGiants()
void placePlanetoidBelts()
void placePlanets()
int getRandomNullOrbit()
IntList availableOrbitsForGiants()
IntList availableOrbitsForPlanetoids()

ArrayList<Star> getCompanions()

Boolean orbitIsTooHot(int)
Boolean orbitIsNull(int)
Boolean orbitIsNullOrEmpty(int)
Boolean orbitInsideStar(int)
Boolean orbitIsFar(int)
Boolean orbitMaskedByCompanion(int)

String sizeToString()
int sizeFromString()

String toString()
JSONObject asJSON()
=====================================

=====================================
Empty extends Orbit
-------------------------------------
-------------------------------------
Empty(Star, int, String)

Boolean isEmpty()
=====================================

// long term this one and Empty may merge together
// but for now it helps to visualize the algorithm steps
// (what if they had a 'memo' field instead?)
=====================================
Forbidden extends Orbit
-------------------------------------
-------------------------------------
Forbidden(Star, int, String)

Boolean isForbidden()
=====================================

// null object added to help build out the
// algorithm - should only exist while the
// system is being populated
// unclear if this will stay in the final design
=====================================
Null extends Orbit
-------------------------------------
-------------------------------------
Null(Star, int, String)

Boolean isNull()
=====================================

=====================================
GasGiant extends Orbit
-------------------------------------
String size                                TBD
-------------------------------------
GasGiant(Star, int, String)

Boolean isGasGiant()

int generateSatelliteCount()
int generateSatelliteSize()

String toString()                 overloaded to show moon list structure
=====================================

=====================================
interface Habitable
-------------------------------------
-------------------------------------
abstract UWP_ScoutsEx generateUWP()
=====================================

=====================================
Planet extends Orbit implements Habitable
-------------------------------------
UWP_ScoutsEx uwp                          ?? 
-------------------------------------
Planet(Orbit, int, String)

int generateSatelliteCount()
int generateSatelliteSize()
UWP_ScoutsEx generateUWP()

Boolean isPlanet()

String toString()                 overloaded to show moon list structure
=====================================

=====================================
Planetoid extends Orbit implements Habitable
-------------------------------------
UWP_ScoutsEx uwp                          ?? 
-------------------------------------
Planetoid(Orbit, int, String)

UWP_ScoutsEx generateUWP()

Boolean isPlanetoid()
=====================================

// still assessing whether following are
// useful - could also implement this
// via queries alone (class + barycenter.class)

=====================================
Moon extends Planet
-------------------------------------
-------------------------------------
Moon(Orbit, String)

Boolean isMoon()
=====================================

=====================================
Ring extends Planetoid
-------------------------------------
-------------------------------------
Ring(Orbit, String)

Boolean isRing()
=====================================


May need to rejigger the Orbit hierarchy. We have three kinds of things
in this tree that need to be mixed together:

- objects that orbit other objects (Orbit hierarchy)
- objects that can have other objects orbiting them (Orbit superclass)
- objects that have a UWP (Habitable superclass)

The first two are the Composite pattern. The contrast between Gas Giant & Planet
on the one hand, and Planet/Moon vs. Planetoid/Ring are the crux of
the matter.

There's shared implementation in both Orbit & Habitable that's worth keeping,
so can't just make one an interface without moving some things around. This 
could be motivation to pull all the query methods up from Habitable. Then
it could be an interface that exposes the UWP mechanics.

                      |   TRUE             |   FALSE          |
----------------------|--------------------|------------------|
Can have children     |   (Orbit)          |   (Habitable)    |
                      |   Star             |   Empty          |
                      |   Gas Giant        |   Forbidden      |
                      |   Planet           |   Null           |
                      |                    |   Planetoid      |
                      |                    |   Moon           |
                      |                    |   Ring           |
----------------------|--------------------|------------------|
Has a UWP             |   (Habitable)      |   (Orbit)        |
                      |   Planet           |   Star           |
                      |   Moon             |   Gas Giant      |
                      |   Planetoid        |   Empty          |
                      |   Ring             |   Forbidden      |
                      |                    |   Null           |
----------------------|--------------------|------------------|

(Orbit)
  Empty
  Forbidden
  Null
  Star
  GasGiant
  (Habitable)    ---- XXX now an interface
    Planet
    Planetoid
    Moon
    Ring

OK, trying this out. Habitable is now an interface used by
Planet & Planetoid.

5/6/23

Reviewed Composite and have some thoughts about cleaning this up. Motivation
is the "find the mainworld" code, which would be much simpler if we could 
walk through the tree uniformly.

In addition to the muddled hierarchy described above, the collections are
implemented differently:

- Stars have an array of Orbits
- Orbits have a TreeMap of Habitables (this isn't used by Stars,
    only by GasGiants + Planets)

So - I think we want a TreeMap of Orbits used by all composite classes.
(Added benefit: the TreeMap would allow Float indices, so we could
handle Captured Planets too.)

In the pattern terminology, the classes are:

Component - (Orbit)
Composite - Star, GasGiant, Planet
Leaf      - Empty, Forbidden, Null, Planetoid, Moon, Ring

(Habitable) as already noted is orthogonal to this structure. It means "has
a UWP" and is an interface implemented by Planet/Moon/Planetoid/Ring.


=========================================
5/26/23

Above reworking is essentially complete (and Scouts is nearly feature complete).
Lots of technical debt and no doubt bugs to handle from here. Exploring the space 
below.


-------------------------------------------
Scenario: NEW, rules == "Scouts (Extended)"
-------------------------------------------

REVIEW for overrides/polymorphic calls

new Subsector()
  [for each coordinate]: 
    ruleset.newSystem()
      System_ScoutsEx.ctor()
        System_CT81.ctor()
          System.ctor()
            [UI/utility stuff]
            [set / if occupied]:
              System_CT81.generateUWP()        // overridden, timing issue, is 'rerun'
                UWP_CT81.ctor()
              System.generateNavalBase()       // timing issue, is rerun
              System.generateScoutBase()       // timing issue, is rerun
              [set / if GasGiant]              // timing issue, is rerun
              System_CT81.generateTradeClass() // overridden, timing issue, is rerun
                TradeClass_CT81.ctor()
              [set name]
              [initialize routes list]
          System_CT81.generateTravelZone()     // -- timing issue, need to rerun
        Star.ctor()
          Orbit.ctor()
          Star.generateType()
          Star.generateSize()
          Star.retrieveOrbitalZones()
        Star.createSatellites()
          Star.generateCompanionCount()
          [for each companion]:
            Star.ctor()
            Star.generateCompanionOrbits()
          Star.calculateMaxOrbits()
          Star.placeNullOrbits()
            Null.ctor()
              Orbit.ctor()
          Star.fillEmptyOrbits()
            Empty.ctor()
              Orbit.ctor()
          Star.placeEmptyOrbits()
            Star.getRandomUnassignedOrbit()
            Empty.ctor()
              Orbit.ctor()
          Star.placeForbiddenOrbits()
            Forbidden.ctor()
              Orbit.ctor()
          Star.placeCapturedPlanets()          // still just a stub
          Star.placeGasGiants()
            Star.availableOrbitsForGiants()
            GasGiant.ctor()
              Orbit.ctor()
              GasGiant.generateSatelliteCount()
              Orbit.createSatellites()
                xxx

          Star.placePlanetoidBelts()
            Star.availableOrbitsForPlanetoids()
            Planetoid.ctor()
              Orbit.ctor()
              Planetoid.generateUWP()
                UWP_ScoutsEx.ctor()
                  UWP_ScoutsEx.generateSize()        // override
                  UWP_ScoutsEx.generateAtmo()        // override
                  UWP_ScoutsEx.generateHydro()       // override
                  UWP_ScoutsEx.generatePop()         // override
          Star.placePlanets()
            Planet.ctor()
              Orbit.ctor()
              Planet.generateUWP()
                UWP_ScoutsEx.ctor()
                  UWP_ScoutsEx.generateSize()        // override
                  UWP_ScoutsEx.generateAtmo()        // override
                  UWP_ScoutsEx.generateHydro()       // override
                  UWP_ScoutsEx.generatePop()         // override
              Planet.generateSatelliteCount()
              Orbit.createSatellites()
                xxx

          [for each companion]:
            Star.createSatellites()
              [as above...]
        [get / set GasGiant]                   // rerunning due to timing issue
        Star.designateMainworld()
          [find highest pop Habitable]
          Habitable.completeUWP()
            UWP_ScoutsEx.completeUWP()
              UWP.generateGov()
              UWP.generateLaw()
              UWP.generateStarport()
              UWP.generateTech()
          [for every other Habitable]:
             Habitable.completeUWP()
               UWP_ScoutsEx.completeUWP()
                 UWP_ScoutsEx.generateSubordinateGov()
                 UWP_ScoutsEx.generateSubordinateLaw()
                 UWP_ScoutsEx.generateSubordinateStarport()
                 UWP_ScoutsEx.generateSubordinateTech()

// 'true' UWP exists from this point

        System.generateNavalBase()             // rerunning due to timing issue
        System.generateScoutBase()             // rerunning due to timing issue
        System_CT81.generateTradeClass()       // rerunning due to timing issue
        System_ScoutsEx.generateFacilities()
  createSummary()                              // timing is OK, post 'true' UWPs
    magnitudeFormatNumber()
    commaFormatList()
  calculateRoutes()                            // timing is OK, post 'true' UWPs

--------------------------
System
  ctors()
  generateTradeClass()
  generateUWP()
  addRoute()
  distanceToSystem()
  generateScoutBase()
  generateNavalBase()
  toString()
  listRoutes()
  asJSON()
System_CT81
  ctors()
  generateTradeClass()                         // OVERRIDE
  generateUWP()                                // OVERRIDE
  generateTravelZone()
  toString()                                   // OVERRIDE
  asJSON()                                     // OVERRIDE
System_ScoutsEx
  ctors()
  generateFacilities()
  toString()                                   // OVERRIDE
  asJSON()                                     // OVERRIDE
  [generateUWP()]                              // -- missing override?
--------------------------
Would it be better to have some sort of factory/builder class handling 
all the timing of events here, rather than confusing ctor chains? Could
greatly simplify what are essentially just data classes after they've been
built.

Alternatively, the root class for each of these little trees is the
data class. Subclasses override generation, but once complete, clients
can just talk to the root interface and eliminate a ton of casting
and visibility into exact types.
--------------------------
Random idea: should we add a common root class for all
these data classes that could provide services (or interface)
for functionality like to/from JSON? (Or maybe just an interface...)

Catalog the classes here:

Traveller 
Button
  Command                 // interface
  NewSubsector
  Load
  ChangeColors
  ChangeRules
  ButtonUtilities
ColorScheme               // asJSON() + ctor(JSONObject)
Coordinate                // asJSON() + ctor(JSONObject)
Dice
  DiceMock
Orbit                     // abstract  -- SHOULD have JSON functionality
  Empty
  Forbidden
  Null
  GasGiant
  Habitable               // interface
  Planet
  Planetoid
  Moon
  Ring
Polygon
Route                     // asJSON() + ctor(JSONObject)
Ruleset                   // -- SHOULD be subclassed
Screen                    // abstract
  Menu
  Display
Star                      // asJSON() + ctor(JSONObject)
Subsector                 // asJSON() + ctor(JSONObject)
SubsectorDisplay
System                    // asJSON() + ctor(JSONObject) -- SHOULD be absract
  System_CT81             // asJSON() + ctor(JSONObject)
  System_ScoutsEx         // asJSON() + ctor(JSONObject)
TestSuite
  HabitableZoneForG0VIs3
  DistanceBetweenSubsectorCornersIsThirteen
  SizeZeroWorldsHaveNoHydrosphere
  SizeZeroWorldsHaveNoAtmosphere
  UnoccupiedSystemsHaveNoUWP
  NavalBaseOnlyAtABStarports
  ScoutBaseOnlyAtABCDStarports
  NoRoutesToRedZones
  TestCase                // -- SHOULD be abstract ?
TextPanel
TradeClass
  TradeClass_CT81
UWP                       // asJSON() + ctor(JSONObject)
  UWP_CT81                // inherited.asJSON() + inherited.ctor(JSONObject)
  UWP_ScoutsEx            // inherited.asJSON() + inherited.ctor(JSONObject)
==========================================================
6/3/23

Scouts generation is feature complete. Time to circle back on app functionality,
code cleanup, and bugs. We'll start with the JSON save/load.

We currently have this JSON structure:

Systems [
  { Naval Base,
    Gas Giant,
    Occupied,
    Travel Zone,
    Coordinate
      { Column,
        Row },
    Scout Base,
    Primary
      { Companions [
         { Orbit,
           Class,
           Orbits [
             "String",
             ... ]},
          ... ]},
         Class,
         Orbits [
           "String",
           ... ]},
    Name,
    UWP
      { Law Level,
        Government,
        Tech Level,
        Starport,
        Size,
        Atmosphere,
        Population,
        Hydrographics }},
  ...]

// --------------------------
The corresponding code flow is:

Subsector.asJSON()
  [for each System]:
    System_ScoutsEx.asJSON()
      System_CT81.asJSON()
        System.asJSON()
          Coordinate.asJSON()   // "Coordinate"
            setInt              // "Column"
            setInt              // "Row"
          setBoolean            // "Occupied"
          setString             // "Name"              
          setBoolean            // "Naval Base"
          setBoolean            // "Scout Base"
          setBoolean            // "Gas Giant"
          UWP.asJSON()          // "UWP"     -- no overrides
            setString           // "Starport"
            setInt              // "Size"
            setInt              // "Atmosphere"
            setInt              // "Hydrographics"
            setInt              // "Population"
            setInt              // "Government"
            setInt              // "Law Level"
            setInt              // "Tech Level"
      setString                 // "Travel Zone"
    Star.asJSON()               // "Primary"
      setString                 // "Class"
      Star.asJSON()             // "Close Companion"
        ...
      [for each Companion]:     // "Companions"
        Star.asJSON()           // array entry
          ...
      [for each Orbit]:         // "Orbits"
        setString               // orbits entry
        ...
      setInt                    // "Orbit"   -- for non-primary entities  
// --------------------------

Obvious first candidate is the String representation for all non-Star
Orbit objects. These should be compound JSONObjects just like the rest. I've
kludged it so far by appending their own satellites to their toString()
representation, but that's not going to support loading.

Nothing in the Orbit hierarchy other than Star currently has asJSON().


